import { Block } from "@share/utility";
import { IChunkData } from ".";

import { ChunkCoordinate, IChunkCoordinate } from "@share/data/coordinate/chunk-coordinate";
import { IRelativeCoordinate, RelativeCoordinate } from "@share/data/coordinate/relative-coordinate";
import { Settings } from "@share/config/Settings";
import { SerializableGrid } from "@share/data/grid/SerializableGrid";

/**
 * Store data for a single chunk, a cubic region of blocks.
 */
export class ChunkData implements IChunkData {

  private constructor(
    private coordinate: IChunkCoordinate,
    private blocks: SerializableGrid<Block, IRelativeCoordinate>
  ) {}

  /**
   * Create an empty ChunkData.
   * @param coord The chunk coordinate of the new chunk.
   * @returns Empty ChunkData object.
   */
  static new(coord: IChunkCoordinate): ChunkData {
    let grid = SerializableGrid.new<Block, IRelativeCoordinate>();
    return new ChunkData(coord, grid);
  }

  /**
   * Create a ChunkData object from a string representation.
   * @param rep The string representation generated by toStringRep().
   * @returns ChunkData populated with blocks from rep.
   */
  static fromStringRep(rep: string): ChunkData {

    // Find end of chunk coordinate
    let i = 3;
    while (rep[i] !== ")") i++;

    // Split string into sections
    const coordStr = rep.substring(0, i + 1);
    const chunkStr = rep.substring(i + 1);

    // Decode strings
    const coord = ChunkCoordinate.fromString(coordStr);
    const blocks = SerializableGrid.fromStringRep<Block, IRelativeCoordinate>(chunkStr, blockStr => {
      return <any>blockStr as Block;
    });

    return new ChunkData(coord, blocks);
  }

  /**
   * Get a string representation of this chunk.
   * @returns A string representation of the blocks
   *   in this chunk.
   */
  toStringRep(): string {
    let coordStr = this.coordinate.toString();
    let blockStr = this.blocks.toStringRep();
    return coordStr + blockStr;
  }

  // Get the size (width, length, height) of a chunk in blocks
  getSize() {
    return Settings.CHUNK_SIZE;
  }

  /**
   * Get the block at a relative coordinate
   * @param coord The position of the block to access.
   * @returns The block.
   * @throws Error if the coordinate is not relative to this chunk.
   */
  getBlock(coord: IRelativeCoordinate): Block {

    // Ensure relative coordinate is relative to this chunk
    if (!coord.chunkCoordinate.equals(this.coordinate)) {
      throw new Error("Cannot get a block outside this chunk");
    }

    const block = this.blocks.get(coord);
    if (block == undefined) {
      return Block.Air;
    }

    return block;
  }

  /**
   * Set a block at a relative coordinate.
   * @param coord The coordiante to update.
   * @param block The block to set at the coordinate.
   */
  setBlock(coord: IRelativeCoordinate, block: Block): void {

    // Ensure relative coordinate is relative to this chunk
    if (!coord.chunkCoordinate.equals(this.coordinate)) {
      throw new Error("Cannot set a block outside this chunk");
    }

    this.blocks.set(coord, block);
  }

  // Get the coordinate of this chunk.
  getCoordinate(): IChunkCoordinate {
    return this.coordinate;
  }

  /**
   * Get iterator for relative coordinates of all non-air blocks in the chunk
   * @returns An iterator for non-air blocks in the chunk.
   */
  *[Symbol.iterator](): Iterator<[IRelativeCoordinate, Block], any, unknown> {
    for (const [coord, block] of this.blocks) {
      if (block != Block.Air) {
        const relCoord = new RelativeCoordinate(coord.x, coord.y, coord.z, this.coordinate);
        yield [relCoord, block];
      }
    }
  }
}
